<!DOCTYPE html>
<html>
    <head>
        <title>flex style</title>
        <meta charset="utf-8">

        <style>
            /* 가장 먼저 자식 div의 스타일링*/
            body{
                border: 1px dotted red; /*오버플로우를 확인할 수 있음*/
            }
            div#container>div{
                background-color: deepskyblue;
                padding: 20px;
                margin: 10px;
                font-weight: bold;
                width: 100px;
                /* align-items의 수평배치 정렬일 때 strech 연습을 적용하기 위해 width값 제거 */
            }
            /* 자식요소들의 배치를 부모요소가 결정하도록:  flex style 적용 */
            #container{
                display: flex; /*자식요소들은 자동으로 inline요소처럼 width값이 wrap이 된다(width 조절 가능)*/

                /* 기본적으로 자식 요소들의 배치방향은 가로(row)방향이다 */
                /* 개수가 많아져서 브라우저 사이즈를 넘어가도 자동 줄바꿈되지 않음 : 일종의 overflow 상황 */

                /* flex-wrap: wrap; 일반적인 inline처럼 줄바꿈이 되게 하는 것 */
                flex-wrap: wrap;
                flex-wrap: wrap-reverse; /*새로운 줄이 위로 생김*/
                flex-wrap: nowrap;

                /* 자식들의 배치 방향 결정 -android의 orientation같은 것 : row-수평 column-수직*/
                flex-direction: column; /*수직 방향*/
                flex-direction: column-reverse; /*요소들이 아래서부터 위로 배치됨*/     
                height: 300px; /*부모 높이값을 크게 하면 reverse에 대해 이해할 수 있음.. 위에서 아래로X 아래에서 위로O*/                
                flex-direction: row;
                flex-direction: row-reverse;

                /* flex-flow : flex-wrap 과 flex-direction의 축약형 */
                flex-flow: row wrap; /*wrap 먼저인지 direction 먼저인지 순서는 상관 없음*/

                flex-flow: row nowrap; /*기본 상태*/
                
                /* 정렬을 위해 자식요소 3개만 사용 */
                /* 1. justify-content: direction 방향의 정렬 */
                /* 1.1 수평 배치(row)일 때 justify-content는 수평 정렬이다 */
                flex-direction: row;
                justify-content: center;
                justify-content: flex-end; /*direction 방향의 끝*/
                justify-content: flex-start; /*direction 방향의 시작(원래 정렬 상태)*/ 
                justify-content: space-between; /*요소 사이의 공간 균등 분할 (시작과 끝이 부모에 딱 붙은 상황) */
                justify-content: space-around; /*요소를 둘러싼 공백이 균등함*/
                justify-content: space-evenly; /**/

                /* 1.2 수직 배치(column)일 때, justify-content는 수직정렬이다 */
                flex-direction: column;
                justify-content: flex-start; /* direction 방향 시작에서부터 배치*/
                justify-content: flex-end; /* direction 방향 끝에서부터 배치*/
                justify-content: center;
                justify-content: space-between; /*요소의 균등분할*/
                justify-content: space-around;
                justify-content: space-evenly;
                justify-content: flex-start;

                flex-direction: row;
                
                /* 2. align-items: direction 방향의 교차축 정렬 */
                /* 2.1 수평배치일 때 수직정렬 */
                align-items: stretch; /*기본 상태 - 요소의 높이값을 부모높이만큼 늘려줌*/
                align-items: flex-start;
                align-items: flex-end;
                align-items: center;
                align-items: baseline; /*각 요소들 안에 있는 컨텐츠들의 아래 라인을 맞춰줌*/

                flex-direction: column;
                /* 2.2 수직배치일 때는 수평정렬 */
                align-items: flex-start;
                align-items: center;
                align-items: flex-end;
                align-items: stretch; /*자식요소의 width값이 있으면 적용 안됨*/
                align-items: baseline; /*글씨의 아래를 맞추는 거리 수직정렬과는 상관 없음*/


                /* 교차축의 space-between, space-around 같은걸 하고싶다면?*/
                flex-flow: row wrap;
                justify-content: flex-start;
                align-content: space-between;
                align-content: space-around;

                flex-flow: column wrap;;
                justify-content: flex-start;
                align-content: space-between;
                align-content: space-around;

            }
        </style>
    </head>

    <body>
        <!-- flex style : 자식요소들의 배치[layout]을 유연하게 하기 위한 스타일 -->
        <!-- 이 flex 스타일은 부모요소에게 display 속성으로 지정함 -->
        <!-- 자식들의 배치 방식을 부모가 결정 -> 마치 안드로이드의 LinearLayout과 비슷한 방법 -->
        <div id="container">
            <div>aa</div>
            <div style="font-size: 30px;">bb</div>
            <div>cc</div>
            <div>dd</div>
            <div>ee</div>
            <div>ff</div>
            <div>gg</div>
            <div>hh</div>
            <!-- <div>ii</div>
            <div>jj</div>
            <div>kk</div>
            <div>ll</div>
            <div>mm</div>
            <div>nn</div> -->
        </div>

        <hr>

        <!-- 가운데 정렬 -->
        <!-- 자식요소들을 가운데 배치 -->
        <div id="aa">
            <h2>Hello</h2>
            <p>testing....</p>
        </div>

        <style>
            #aa{
               height: 200px; 
               background-color: darkseagreen;
               
               /* 자식요소를 정가운데로 */
               display: flex;
               justify-content: center;
               align-items: center;
               /* 요소들의 배치를 수직으로 */
               flex-direction: column;
            }
            #aa h2{
                text-align: center;
                vertical-align: middle;
            }
        </style>

        <!-- 자식들 입장에서의 flex -->
        <!-- 부모요소가 display:fles일 때만 사용 가능 -->
        <div id="container2">
            <div id="ch1">aaa</div>
            <div id="ch2">bbb</div>
            <div id="ch3">ccc</div>
        </div>
        <style>
            #container2{
                display: flex;
                /* 별도의 방향을 정하지 않으면 row 방향 */

            }
            #container2 div{
                background-color: lightsalmon;
                padding: 20px;
                margin: 10px;
            }
            /* 자식요소들에게 설정하는 flex 스타일 */
            /* 1. order: 배치 순서 변경(숫자가 낮은게 먼저 배치) */
            #ch1{
                order: 3;
            }
            #ch2{
                order: 1;
            }
            #ch3{
                order: 2;
            }
            /* 2. flow-grow: 너비를 상대적인 값의 비례로 지정(마치 android의 weight과 같은 개념) */
            #ch1{
                order: 1;
                flex-grow: 1;
            }
            #ch2{
                order: 2;
                flex-grow: 1;
            }
            #ch3{
                order: 3;
                flex-grow: 6;
            }
            /* 3. flex-shrink: 나머지 flex 아이템과 비교하여 이 요소를 얼마나 줄일지 */
            /* 별도 테스트 */

            /* 4. flex-basis: 요소들의 초기 길이를 지정 */
            /* width와의 차이점: 브라우저 확인이 작아지면 flex-basis로 된 요소들이 먼저 줄어든다 */
            #ch1{
                order: 1;
                flex-grow: 0;
            }
            #ch2{
                order: 2;
                flex-grow: 0;  
                flex-basis: 200px;
            }
            #ch3{
                order: 3;
                flex-grow: 0;
                flex-basis: 300px;
            }
            /* flex 속성(-grow, -shrink, -basis의 축약형) */
            #ch1{
                flex: 0 0 0px;
            }
            #ch2{
                flex: 1 0 0px;
            }
            #ch3{
                flex: 1 0 0px;
            }
            /* 보통은 grow만 많이 사용되기 때문에 축약형도 */
            #ch1{flex: 1;}
            #ch2{flex: 2;}
            #ch3{flex: 3;}
               
            /* 자식요소만의 별도 정렬 */
            /* - 부모요소가 하던 align-itmes / justify-content를 스스로 */
            #container2{
                flex-direction: row;
                /* 세로축 정렬을 알아보기 위해 높이 지정 */
                height: 300px;
            }
            #container2 div{
                height: 100px;
            }
            #ch2{
                align-self: center;
            }
            #ch3{
                align-self: flex-end;
            }





        </style>
    </body>
</html>