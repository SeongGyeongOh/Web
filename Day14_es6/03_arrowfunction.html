<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>
        // 화살표함수 - 함수의 또 다른 문법(자바의 람다식과 유사함)
        
        // 1. 선언적 함수
        function show() {
            document.write('show<br>');
        }
        show();

        // 2. 익명함수
        let output=function(){
            document.write('output<br>');
        }
        output();

        // 3. 화살표함수(익명함수를 줄여쓰는 것)   
        let display=()=>{
            document.write('display<br>');
        }
        display();

        //화살표함수도 파라미터 받을 수 ㅣㅇㅆ음
        let display2=(name, age)=>{
            document.write(name+age+'display2<br>');
        }
        display2("이름", 10);
        
        // 화살표함수의 축약표현이 점점 줄어듬...
        // 1)만약 파라미터가 1개라면 () 생략 가능
        let display3=name=>{
            document.write(name+' display3<br>');
        }
        display3("이름");

        // 2) 실행문이 한 줄이면 {}도 생략 가능
        let display4=name=> document.write(name+ ' display4<br>'); 
        display4("생략중");

        // 만약에 파라미터가 2개 이상이거나 0개이면 ()생략 불가
        let display5=()=> document.write('display5<br>');
        display5();
        let display6=(name, age)=> document.write(name+' , '+age+', display6<br>');
        display6("파라미터 2개", 2);
    </script>

    <!-- 실무에서는 이벤트 처리 함수로 많이 사용함 -->
    <button id="btn1">button</button>
    <p id="p1"></p>

    <script>
        // // 버튼에 클릭이벤트 달기 - 예전 방식
        let btn=document.getElementById('btn1');
        // btn.onclick=function(){
        //     document.getElementById('pp').innerHTML="예전 방식으로 클릭이벤트 처리";
        // }

        // // 화살표 함수르 ㄹ쓴다면?
        btn.onclick=()=>document.getElementById('p1').innerHTML="화살표함수 사용";

        // 반복문 처리에도 좋음
        let arrs= [10, 20, 30];
        document.getElementById('p1').innerHTML= arrs[0]+",";
        document.getElementById('p1').innerHTML+= arrs[1]+",";
        document.getElementById('p1').innerHTML+= arrs[2]+"<br>";
        

        for(let i=0;i<arr.length;i++){
            document.getElementById('p1').innerHTML+=arrs[i]+',';
        }
        document.write('<br>');

        // // 배열객체에 forEach가 생김
        // // arr.forEach(function(value, index, array){});
        // arr.forEach(function(value){
        //     document.getElementById('p1').innerHTML+=value+', ';
        // });

        // arr.forEach(value=>document.getElementById('p1').innerHTML+=value+', ');


        // 배열의 요소들 각각에 접근하여 원하는 작업을 수행하고 그 결과를 다시 리턴해서 새로운 배열로 만드는 함수
        // map
        var arr=[10, 20, 30];

        var newArr=arr.map((value)=>{return value+1});
        document.write(newArr+'<br>');

        //만약, 함수의 실행문이 1줄이면 {}를 생략할 수 있지만, 그 실행문이 리턴이면 리턴 글씨조차 없애야 한다
        // 그리고, 세미콜론도 없애야 한다
        let aaa=arr.map((value)=>value*2);
        document.write(aaa+'<br>');
        
    </script>

    <hr>
    <!-- 일반 함수와 화살표함수의 큰 차이점 -->
    <button id="b2">button2</button>
    <h3 id="hh"></h3>

    <script>
        let b2=document.getElementById('b2');
        // 익명함수로 클릭이벤트 처리 :this의 차이
        // b2.onclick=function(){
        //     document.getElementById('hh').innerHTML=this; //여기서의 this는 함수를 발동시킨 버튼
        // }

        // 화살표함수로 클릭이벤트 처리 : this의 차이
        b2.onclick=()=>{
            document.getElementById('hh').innerHTML=this; //여기서의 this는 감싸는 버튼이 아니라 그것을 감싼 window
        }
    </script>
    
</body>
</html>